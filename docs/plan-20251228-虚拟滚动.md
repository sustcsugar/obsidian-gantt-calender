# 虚拟滚动功能技术方案

**日期**: 2025-12-28
**状态**: 已实施（方案 C - Intersection Observer）
**优先级**: 高（性能优化）

---

## 一、背景与目标

### 1.1 背景

当前 TaskView 使用 `tasks.forEach()` 直接渲染所有任务到 DOM 中。当任务数量超过 100 时，会明显影响页面性能：
- 初始加载缓慢
- 滚动卡顿
- 内存占用高

### 1.2 目标

实现虚拟滚动功能，只渲染可见区域的任务，提升大量任务时的性能。

---

## 二、当前实现分析

### 2.1 CSS 结构

```css
/* 容器样式 (styles.css line 297) */
.gc-view--task {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 12px;
  height: auto;        /* 问题：高度自适应，会塌陷 */
  flex: none;
  overflow: visible;
  width: 100%;
}

/* 任务卡片基础样式 (styles.css line 735) */
.gc-task-card {
  display: flex;
  align-items: center;
  padding: 8px;
  background-color: var(--background-secondary);
}

/* 任务视图卡片样式 */
.gc-task-card--task {
  padding: 10px;
  gap: 8px;
  flex-wrap: wrap;     /* 问题：自动换行，高度不固定 */
  font-size: 13px;
  /* 没有固定高度 */
}
```

### 2.2 当前渲染逻辑

```typescript
// TaskView.ts (line 162)
tasks.forEach(task => this.renderTaskItem(task, listContainer));

// 每个任务卡片直接 append 到 listContainer
// 使用 TaskCardComponent 渲染
// 布局依赖 flex-wrap 自动换行
```

### 2.3 问题总结

| 问题 | 描述 | 影响 |
|------|------|------|
| 容器高度自适应 | `height: auto` 导致高度塌陷 | 虚拟滚动无法正确计算滚动区域 |
| 卡片高度不固定 | `flex-wrap: wrap` + 内容自适应 | 无法精确计算可见范围 |
| CSS 样式复杂 | 嵌套 flex 布局，多级选择器 | 修改容易引发副作用 |
| 事件绑定复杂 | 点击、拖拽、tooltip 等 | 虚拟滚动需要正确处理事件 |

---

## 三、技术方案对比

### 3.1 方案 A：分页加载（最简单）

**描述**：每次只渲染固定数量的任务（如50个），底部添加"加载更多"按钮。

**优点**：
- 实现简单
- 不改变现有布局
- 易于维护

**缺点**：
- 不是真正的虚拟滚动
- 大量任务时仍需多次点击加载

### 3.2 方案 B：时间分片渲染

**描述**：使用 `requestIdleCallback` 分批渲染，每批渲染20个任务。

**优点**：
- 不改变 DOM 结构
- 用户体验较好

**缺点**：
- 最终仍会渲染所有任务
- 无法解决内存占用问题

### 3.3 方案 C：Intersection Observer 虚拟滚动（推荐）

**描述**：使用 Intersection Observer API 检测可见性，只显示可见区域+缓冲区的任务。

**优点**：
- 不使用绝对定位，保持原有 flex 布局
- 浏览器原生 API，性能优化
- 最小化 CSS 冲突
- 易于理解和维护

**缺点**：
- 需要维护显示/隐藏状态
- 初始渲染时创建所有 DOM 节点（但隐藏）

---

## 四、推荐方案详细设计（方案 C）

### 4.1 核心思路

```
┌─────────────────────────────────────┐
│   .gc-task-scroll-container          │  ← 滚动容器
│   ├─ .gc-task-card [display: none]   │  ← 不可见任务
│   ├─ .gc-task-card [display: flex]   │  ← 可见任务
│   ├─ .gc-task-card [display: flex]   │  ← 可见任务
│   ├─ .gc-task-card [display: none]   │  ← 不可见任务
│   └─ .gc-task-card [display: none]   │  ← 不可见任务（缓冲区）
└─────────────────────────────────────┘
         ↑
    Intersection Observer 监听可见性
    rootMargin: 200px (缓冲区)
```

**关键点**：
1. 渲染所有任务的 DOM 节点
2. 初始使用 `display: none` 隐藏所有
3. 使用 Intersection Observer 监听可见性
4. 只在可见区域 + 缓冲区显示任务

### 4.2 实现步骤

#### Step 1: 创建 VisibilityManager 类

**文件**: `src/utils/visibility/VisibilityManager.ts`

```typescript
/**
 * 可见性管理器
 * 使用 Intersection Observer 管理任务卡片的显示/隐藏
 */
export class VisibilityManager {
  private observer: IntersectionObserver | null = null;
  private observedItems = new Map<HTMLElement, (isVisible: boolean) => void>();
  private rootElement: HTMLElement;
  private bufferDistance: number;

  constructor(rootElement: HTMLElement, bufferDistance: number = 200) {
    this.rootElement = rootElement;
    this.bufferDistance = bufferDistance;
    this.initObserver();
  }

  private initObserver(): void {
    const options: IntersectionObserverInit = {
      root: this.rootElement,
      rootMargin: `${this.bufferDistance}px 0px ${this.bufferDistance}px 0px`,
      threshold: 0.01
    };

    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const callback = this.observedItems.get(entry.target as HTMLElement);
        if (callback) {
          callback(entry.isIntersecting);
        }
      });
    }, options);
  }

  /**
   * 观察一个元素
   */
  observe(element: HTMLElement, onVisibilityChange: (isVisible: boolean) => void): void {
    if (!this.observer) {
      this.initObserver();
    }
    this.observedItems.set(element, onVisibilityChange);
    this.observer.observe(element);
  }

  /**
   * 停止观察所有元素
   */
  disconnect(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observedItems.clear();
      this.observer = null;
    }
  }

  /**
   * 刷新观察（用于数据更新后）
   */
  refresh(): void {
    this.disconnect();
    this.observedItems.clear();
  }

  /**
   * 销毁
   */
  destroy(): void {
    this.disconnect();
    this.observedItems.clear();
  }
}
```

#### Step 2: 创建模块导出

**文件**: `src/utils/visibility/index.ts`

```typescript
export { VisibilityManager } from './VisibilityManager';
```

#### Step 3: 修改 TaskView 使用 VisibilityManager

**文件**: `src/views/TaskView.ts`

修改点：
1. 添加 `visibilityManager` 属性
2. 在 `render()` 方法中创建滚动容器
3. 在 `loadTaskList()` 中创建 VisibilityManager
4. 在 `renderTaskItem()` 中设置可见性监听

```typescript
import { VisibilityManager } from '../utils/visibility/VisibilityManager';

export class TaskViewRenderer extends BaseCalendarRenderer {
  // 添加可见性管理器属性
  private visibilityManager?: VisibilityManager;
  private scrollContainer?: HTMLElement;

  render(container: HTMLElement, currentDate: Date): void {
    const taskRoot = container.createDiv(withModifiers(ViewClasses.block, ViewClasses.modifiers.task));

    // 创建滚动容器
    this.scrollContainer = taskRoot.createDiv('gc-task-scroll-container');
    this.loadTaskList(this.scrollContainer);
  }

  private async loadTaskList(listContainer: HTMLElement): Promise<void> {
    listContainer.empty();
    listContainer.createEl('div', { text: '加载中...', cls: 'gantt-task-empty' });

    try {
      let tasks: GanttTask[] = this.plugin.taskCache.getAllTasks();

      // ... 筛选逻辑保持不变 (lines 109-153) ...

      listContainer.empty();

      if (tasks.length === 0) {
        listContainer.createEl('div', { text: '未找到符合条件的任务', cls: 'gantt-task-empty' });
        return;
      }

      // 清理旧的可见性管理器
      if (this.visibilityManager) {
        this.visibilityManager.destroy();
      }

      // 创建可见性管理器
      this.visibilityManager = new VisibilityManager(listContainer, 200);

      // 渲染所有任务（初始隐藏）
      tasks.forEach(task => this.renderTaskItem(task, listContainer));

    } catch (error) {
      console.error('Error rendering task view', error);
      listContainer.empty();
      listContainer.createEl('div', { text: '加载任务时出错', cls: 'gantt-task-empty' });
    }
  }

  private renderTaskItem(task: GanttTask, listContainer: HTMLElement): void {
    // 创建任务卡片
    new TaskCardComponent({
      task,
      config: TaskViewConfig,
      container: listContainer,
      app: this.app,
      plugin: this.plugin,
      onClick: (clickedTask) => {
        // 刷新任务列表
        if (this.scrollContainer) {
          this.loadTaskList(this.scrollContainer);
        }
      },
    }).render();

    // 获取刚创建的任务卡片元素
    const taskCard = listContainer.lastElementChild as HTMLElement;
    if (!taskCard) return;

    // 初始设置为隐藏
    taskCard.style.display = 'none';

    // 使用可见性管理器监听
    if (this.visibilityManager) {
      this.visibilityManager.observe(taskCard, (isVisible) => {
        taskCard.style.display = isVisible ? '' : 'none';
      });
    }
  }
}
```

#### Step 4: 添加 CSS 样式

**文件**: `styles.css`

在文件末尾添加：

```css
/* ========================================
   可见性管理（虚拟滚动）
   ======================================== */

/* 滚动容器 */
.gc-task-scroll-container {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: visible;
}

/* 滚动条样式 */
.gc-task-scroll-container::-webkit-scrollbar {
  width: 8px;
}

.gc-task-scroll-container::-webkit-scrollbar-track {
  background: var(--background-secondary);
}

.gc-task-scroll-container::-webkit-scrollbar-thumb {
  background: var(--background-modifier-border);
  border-radius: 4px;
}

.gc-task-scroll-container::-webkit-scrollbar-thumb:hover {
  background: var(--text-faint);
}
```

---

## 五、关键文件清单

| 文件 | 操作 | 说明 |
|------|------|------|
| `src/utils/visibility/VisibilityManager.ts` | 新建 | 可见性管理器核心类 |
| `src/utils/visibility/index.ts` | 新建 | 模块导出 |
| `src/views/TaskView.ts` | 修改 | 集成可见性管理器 |
| `styles.css` | 修改 | 添加滚动容器样式 |

---

## 六、验证清单

实施完成后请验证：

- [ ] TaskView 中任务正常显示
- [ ] 滚动流畅，任务按需显示
- [ ] 滚动到底部能看到所有任务
- [ ] 任务点击功能正常
- [ ] 任务拖拽功能正常
- [ ] 筛选功能正常
- [ ] 排序功能正常
- [ ] 100+ 任务时性能有明显提升

---

## 七、回滚计划

如需回滚，执行以下步骤：

```bash
# 1. 删除新增文件
rm -rf src/utils/visibility/

# 2. 恢复原始文件
git checkout src/views/TaskView.ts styles.css

# 3. 重新构建
npm run build
```

---

## 八、Debug 手段

### 8.1 控制台日志

VisibilityManager 内置了完整的调试日志系统，默认启用。日志前缀为 `[TaskView]`。

#### 日志类别

| 类别 | 用途 | 示例 |
|------|------|------|
| `CONSTRUCTOR` | 初始化信息 | `[TaskView] 初始化 - bufferDistance: 200px` |
| `INIT` | Observer 创建/销毁 | `[TaskView] 创建 IntersectionObserver` |
| `OBSERVE` | 元素观察注册 | `[TaskView] 开始观察元素 - 总数: 50` |
| `VISIBILITY` | 可见性变化 | `[TaskView] 元素 进入可见区` |
| `STATS` | 统计信息（每10秒） | `[TaskView] 统计 - 总数: 100, 可见: 15 (15.0%)` |
| `WARNING` | 警告信息 | `[TaskView] WARNING: Observer 未初始化` |
| `ERROR` | 错误信息 | `[TaskView] ERROR: 任务卡片创建失败` |

#### 查看日志

打开浏览器开发者工具（F12），切换到 Console 标签：

```javascript
// 过滤只显示虚拟滚动相关日志
// 在 Console 过滤框输入: [TaskView]
```

#### 日志示例

```
[TaskView] [14:23:05.123] CONSTRUCTOR: 初始化 - bufferDistance: 200px, debug: true
[TaskView] [14:23:05.125] INIT: 创建 IntersectionObserver - rootMargin: 200px 0px 200px 0px
[TaskView] [14:23:05.200] 开始渲染任务列表，任务数量: 85
[TaskView] [14:23:05.201] OBSERVE: 开始观察元素 - 总数: 1, "任务标题1"
[TaskView] [14:23:05.202] OBSERVE: 开始观察元素 - 总数: 2, "任务标题2"
...
[TaskView] [14:23:05.450] VISIBILITY: 元素 进入可见区 - "任务标题5" {isVisible: true, ratio: 0.5}
[TaskView] [14:23:05.451] VISIBILITY: 元素 进入可见区 - "任务标题6" {isVisible: true, ratio: 0.8}
[TaskView] [14:23:06.100] STATS: 统计 - 总数: 85, 可见: 12 (14.1%), 隐藏: 73
```

### 8.2 程序化获取统计信息

在浏览器 Console 中直接调用 API 获取实时统计：

```javascript
// 获取 VisibilityManager 实例（通过插件）
const plugin = app.plugins.plugins['obsidian-gantt-calendar'];
// 注意：需要通过暴露的 API 或在代码中添加获取方法

// 或者直接在 VisibilityManager 代码中添加测试：
// visibilityManager.logStats();  // 输出当前统计
// visibilityManager.getStats();  // 返回统计数据对象
```

### 8.3 可视化 Debug 信息

在 TaskView.ts 中可以启用可视化 debug 面板：

```typescript
// 在 loadTaskList() 中添加（已集成）
this.visibilityManager.showDebugInfo(debugContainer);
```

显示效果：
```
总任务数: 85
可见任务: 12
隐藏任务: 73
缓冲距离: 200px
```

### 8.4 常见问题排查

#### 问题1：任务全部不显示

**症状**：任务列表空白

**排查**：
```javascript
// Console 查看是否有 OBSERVE 日志
// 查看是否有错误日志

// 检查 DOM 结构
document.querySelectorAll('.gc-task-card').length  // 应该 > 0

// 检查滚动容器
document.querySelector('.gc-task-scroll-container')  // 应该存在
```

#### 问题2：滚动时任务不显示/隐藏

**症状**：滚动后可见任务数量不变

**排查**：
```javascript
// 查看 VISIBILITY 日志是否有更新
// 检查 IntersectionObserver 是否触发
```

#### 问题3：性能未提升

**症状**：100+ 任务时仍然卡顿

**排查**：
```javascript
// 查看 STATS 日志
// 确认可见任务占比（应该 < 30%）
// 检查是否有内存泄漏
```

### 8.5 禁用 Debug 模式

在生产环境中禁用调试日志：

```typescript
// TaskView.ts 中修改
this.visibilityManager = new VisibilityManager(
    listContainer,
    200,
    { enabled: false }  // 禁用日志
);
```

或运行时动态切换：

```typescript
this.visibilityManager?.setDebugEnabled(false);
```

### 8.6 性能监控

使用浏览器 Performance 面板监控：

1. 打开 DevTools → Performance
2. 点击 Record
3. 滚动任务列表
4. 停止 Record
5. 查看：
   - Long Tasks (应 < 50ms)
   - Layout Shift (应最小)
   - FPS (应保持 60)

---
